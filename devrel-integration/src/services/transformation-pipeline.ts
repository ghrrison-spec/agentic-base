/**
 * Transformation Pipeline
 *
 * Sprint 2 - Task 2.4: Transformation Pipeline Integration
 *
 * Integrates Google Docs storage, persona prompts, and context aggregation into
 * a unified transformation pipeline. Generates 4 persona-specific summaries from
 * a single technical document and stores them in Google Docs.
 *
 * Features:
 * - Orchestrates end-to-end transformation process
 * - Integrates all security controls (sanitization, secret scanning, validation)
 * - Stores outputs in Google Docs with correct folder/permissions
 * - Creates bidirectional links between documents
 * - Comprehensive error handling and retry logic
 * - Graceful degradation for partial failures
 * - Audit logging for all operations
 */

import { logger, auditLog } from '../utils/logger';
import googleDocsStorage, {
  GoogleDocsStorageService,
  CreateDocumentResult,
  Permission,
  DocumentMetadata,
} from './google-docs-storage';
import unifiedContextAggregator, {
  UnifiedContextAggregator,
  UnifiedContext,
  AggregationOptions,
} from './unified-context-aggregator';
import {
  generatePersonaPrompt,
  PersonaType,
  PersonaPromptParams,
  DocumentType,
  getAvailablePersonas,
  validatePromptParams,
  estimateOutputTokens,
} from '../prompts/persona-prompts';
import contentSanitizer from './content-sanitizer';
import secretScanner from './secret-scanner';
import outputValidator from './output-validator';
import reviewQueue from './review-queue';
import secureTranslationInvoker from './translation-invoker-secure';
import * as fs from 'fs';
import * as path from 'path';

// =============================================================================
// Types and Interfaces
// =============================================================================

export interface TransformationInput {
  sourceDocument: {
    name: string;
    content: string;
    path: string;
  };
  projectName: string;
  documentType: DocumentType;
  /** If true, fetch Linear/GitHub/Discord context */
  aggregateContext?: boolean;
  /** Aggregation options for context fetching */
  aggregationOptions?: AggregationOptions;
  /** Target personas (default: all 4) */
  targetPersonas?: PersonaType[];
  /** Folder IDs for storing outputs (persona -> folderId) */
  folderMapping?: Record<PersonaType, string>;
  /** Permission mapping (persona -> permissions) */
  permissionMapping?: Record<PersonaType, Permission[]>;
  /** Store original document in Google Docs */
  storeOriginal?: boolean;
  /** Create bidirectional links between documents */
  createLinks?: boolean;
  /** User who requested the transformation */
  requestedBy?: string;
}

export interface PersonaSummary {
  persona: PersonaType;
  documentId: string;
  webViewLink: string;
  title: string;
  folderId: string;
  generatedAt: Date;
  tokenCount: number;
}

export interface TransformationResult {
  personaSummaries: Partial<Record<PersonaType, PersonaSummary>>;
  originalDocument?: {
    documentId: string;
    webViewLink: string;
  };
  metadata: {
    generatedAt: Date;
    sourceDocuments: string[];
    transformationDurationMs: number;
    warnings: string[];
    errors: string[];
    securityScanResults: {
      sanitizationApplied: boolean;
      secretsDetected: number;
      secretsRedacted: number;
      validationPassed: boolean;
      flaggedForReview: boolean;
    };
  };
}

export interface FolderConfig {
  leadership: string;
  product: string;
  marketing: string;
  devrel: string;
  originals: string;
}

// =============================================================================
// Transformation Pipeline Service
// =============================================================================

export class TransformationPipeline {
  private googleDocs: GoogleDocsStorageService;
  private contextAggregator: UnifiedContextAggregator;
  private folderConfig: FolderConfig | null = null;

  constructor(
    googleDocs: GoogleDocsStorageService = googleDocsStorage,
    contextAggregator: UnifiedContextAggregator = unifiedContextAggregator
  ) {
    this.googleDocs = googleDocs;
    this.contextAggregator = contextAggregator;
  }

  /**
   * Initialize the pipeline
   */
  async initialize(): Promise<void> {
    logger.info('Initializing Transformation Pipeline');

    // Initialize Google Docs service
    await this.googleDocs.initialize();

    // Load folder configuration
    await this.loadFolderConfig();

    logger.info('Transformation Pipeline initialized');
  }

  /**
   * Load folder IDs from configuration
   */
  private async loadFolderConfig(): Promise<void> {
    try {
      // Try to load from config/folder-ids.json (generated by Terraform setup script)
      const configPath = path.join(
        process.cwd(),
        'config',
        'folder-ids.json'
      );

      if (fs.existsSync(configPath)) {
        const config = JSON.parse(fs.readFileSync(configPath, 'utf-8'));
        this.folderConfig = {
          leadership: config.leadership || config.summaries?.leadership,
          product: config.product || config.summaries?.product,
          marketing: config.marketing || config.summaries?.marketing,
          devrel: config.devrel || config.summaries?.devrel,
          originals: config.originals || config.products,
        };
        logger.info('Folder configuration loaded', { config: this.folderConfig });
      } else {
        logger.warn('Folder configuration not found', { configPath });
        // Use environment variables as fallback
        this.folderConfig = {
          leadership: process.env.GOOGLE_FOLDER_LEADERSHIP || '',
          product: process.env.GOOGLE_FOLDER_PRODUCT || '',
          marketing: process.env.GOOGLE_FOLDER_MARKETING || '',
          devrel: process.env.GOOGLE_FOLDER_DEVREL || '',
          originals: process.env.GOOGLE_FOLDER_ORIGINALS || '',
        };
      }
    } catch (error) {
      logger.error('Failed to load folder configuration', {
        error: error instanceof Error ? error.message : String(error),
      });
      throw error;
    }
  }

  /**
   * Execute transformation pipeline
   */
  async transform(input: TransformationInput): Promise<TransformationResult> {
    const startTime = Date.now();
    const {
      sourceDocument,
      projectName,
      documentType,
      aggregateContext = false,
      aggregationOptions = {},
      targetPersonas = getAvailablePersonas(),
      folderMapping,
      permissionMapping,
      storeOriginal = true,
      createLinks = true,
      requestedBy = 'system',
    } = input;

    logger.info('Starting transformation pipeline', {
      projectName,
      documentType,
      sourceDocumentPath: sourceDocument.path,
      targetPersonas,
      aggregateContext,
    });

    const result: TransformationResult = {
      personaSummaries: {},
      metadata: {
        generatedAt: new Date(),
        sourceDocuments: [sourceDocument.path],
        transformationDurationMs: 0,
        warnings: [],
        errors: [],
        securityScanResults: {
          sanitizationApplied: false,
          secretsDetected: 0,
          secretsRedacted: 0,
          validationPassed: true,
          flaggedForReview: false,
        },
      },
    };

    try {
      // ========================================================================
      // Step 1: Aggregate context (if enabled)
      // ========================================================================
      let unifiedContext: UnifiedContext | null = null;

      if (aggregateContext) {
        try {
          unifiedContext = await this.contextAggregator.aggregateContext(
            sourceDocument.path,
            projectName,
            {
              ...aggregationOptions,
              requestedBy,
            }
          );
          result.metadata.sourceDocuments = unifiedContext.sourceDocuments.map(d => d.path);
          result.metadata.warnings.push(...unifiedContext.metadata.warnings);
        } catch (error) {
          const errorMsg = `Context aggregation failed: ${error instanceof Error ? error.message : String(error)}`;
          result.metadata.warnings.push(errorMsg);
          logger.warn(errorMsg);
          // Continue without aggregated context (graceful degradation)
        }
      }

      // ========================================================================
      // Step 2: Sanitize source content
      // ========================================================================
      const sanitizationResult = contentSanitizer.sanitizeContent(sourceDocument.content);
      result.metadata.securityScanResults.sanitizationApplied = sanitizationResult.flagged;

      if (sanitizationResult.flagged) {
        logger.warn('Content sanitization applied', {
          removedCount: sanitizationResult.removed.length,
          reason: sanitizationResult.reason,
        });
        result.metadata.warnings.push(
          `Content sanitization applied: ${sanitizationResult.reason}`
        );
      }

      // ========================================================================
      // Step 3: Scan for secrets
      // ========================================================================
      const secretScanResult = secretScanner.scanForSecrets(sanitizationResult.sanitized);
      result.metadata.securityScanResults.secretsDetected = secretScanResult.totalSecretsFound;
      result.metadata.securityScanResults.secretsRedacted = secretScanResult.totalSecretsFound;

      if (secretScanResult.hasSecrets) {
        logger.warn('Secrets detected and redacted', {
          totalSecrets: secretScanResult.totalSecretsFound,
          criticalSecrets: secretScanResult.criticalSecretsFound,
        });
        result.metadata.warnings.push(
          `${secretScanResult.totalSecretsFound} secrets detected and redacted`
        );
      }

      // Use redacted content for transformation
      const sanitizedContent = secretScanResult.redactedContent;

      // ========================================================================
      // Step 4: Store original document (if enabled)
      // ========================================================================
      if (storeOriginal) {
        try {
          const originalFolderId = folderMapping?.devrel || this.folderConfig?.originals;

          if (originalFolderId) {
            const originalDoc = await this.googleDocs.createDocument({
              title: `[Original] ${sourceDocument.name}`,
              content: sanitizedContent,
              folderId: originalFolderId,
              metadata: {
                title: sourceDocument.name,
                projectName,
                generatedAt: new Date(),
                version: '1.0',
              },
            });

            result.originalDocument = {
              documentId: originalDoc.documentId,
              webViewLink: originalDoc.webViewLink,
            };

            logger.info('Original document stored', {
              documentId: originalDoc.documentId,
            });
          }
        } catch (error) {
          const errorMsg = `Failed to store original document: ${error instanceof Error ? error.message : String(error)}`;
          result.metadata.warnings.push(errorMsg);
          logger.warn(errorMsg);
          // Continue with transformations
        }
      }

      // ========================================================================
      // Step 5: Generate persona summaries
      // ========================================================================
      const createdDocuments: Array<{ persona: PersonaType; documentId: string }> = [];

      for (const persona of targetPersonas) {
        try {
          const summary = await this.generatePersonaSummary(
            persona,
            sanitizedContent,
            projectName,
            documentType,
            unifiedContext,
            folderMapping,
            permissionMapping,
            requestedBy
          );

          result.personaSummaries[persona] = summary;
          createdDocuments.push({ persona, documentId: summary.documentId });

          logger.info('Persona summary generated', {
            persona,
            documentId: summary.documentId,
          });
        } catch (error) {
          const errorMsg = `Failed to generate ${persona} summary: ${error instanceof Error ? error.message : String(error)}`;
          result.metadata.errors.push(errorMsg);
          logger.error(errorMsg);
          // Continue with other personas (graceful degradation)
        }
      }

      // ========================================================================
      // Step 6: Create bidirectional links (if enabled)
      // ========================================================================
      if (createLinks && result.originalDocument && createdDocuments.length > 0) {
        try {
          await this.createBidirectionalLinks(
            result.originalDocument.documentId,
            createdDocuments
          );
          logger.info('Bidirectional links created');
        } catch (error) {
          const errorMsg = `Failed to create links: ${error instanceof Error ? error.message : String(error)}`;
          result.metadata.warnings.push(errorMsg);
          logger.warn(errorMsg);
        }
      }

      // ========================================================================
      // Step 7: Finalize result
      // ========================================================================
      result.metadata.transformationDurationMs = Date.now() - startTime;

      // Audit log
      auditLog.documentOperation(requestedBy, 'transform', {
        projectName,
        documentType,
        personaCount: Object.keys(result.personaSummaries).length,
        durationMs: result.metadata.transformationDurationMs,
        securityScanResults: result.metadata.securityScanResults,
      });

      logger.info('Transformation pipeline complete', {
        personaCount: Object.keys(result.personaSummaries).length,
        durationMs: result.metadata.transformationDurationMs,
        warningCount: result.metadata.warnings.length,
        errorCount: result.metadata.errors.length,
      });

      return result;
    } catch (error) {
      // Critical error - attempt rollback
      logger.error('Transformation pipeline failed', {
        error: error instanceof Error ? error.message : String(error),
      });

      // Note: Rollback would delete any partially created documents
      // This is left as a warning since deletion might not be desired

      result.metadata.errors.push(
        `Pipeline failed: ${error instanceof Error ? error.message : String(error)}`
      );
      result.metadata.transformationDurationMs = Date.now() - startTime;

      throw error;
    }
  }

  /**
   * Generate a single persona summary
   */
  private async generatePersonaSummary(
    persona: PersonaType,
    sanitizedContent: string,
    projectName: string,
    documentType: DocumentType,
    context: UnifiedContext | null,
    folderMapping?: Record<PersonaType, string>,
    permissionMapping?: Record<PersonaType, Permission[]>,
    requestedBy?: string
  ): Promise<PersonaSummary> {
    const startTime = Date.now();

    // Build prompt parameters
    const promptParams: PersonaPromptParams = {
      documentType,
      projectName,
      sourceContent: sanitizedContent,
      additionalContext: context
        ? {
            linearIssues: context.linearIssues,
            githubPRs: context.githubPRs,
            discordFeedback: context.discordFeedback,
            sprintId: context.metadata.sprintId,
          }
        : undefined,
    };

    // Validate prompt parameters
    const validation = validatePromptParams(promptParams);
    if (!validation.valid) {
      throw new Error(`Invalid prompt parameters: ${validation.errors.join(', ')}`);
    }

    // Generate the prompt
    const prompt = generatePersonaPrompt(persona, promptParams);

    // Invoke secure translation
    const translationResult = await secureTranslationInvoker.generateSecureTranslation({
      documents: [
        {
          name: `${projectName} - ${documentType}`,
          content: sanitizedContent,
        },
      ],
      format: persona,
      audience: this.getAudienceForPersona(persona),
      requestedBy: requestedBy || 'system',
    });

    // Validate output
    const outputValidation = outputValidator.validateOutput(
      translationResult.content,
      persona,
      this.getAudienceForPersona(persona)
    );

    if (!outputValidation.valid) {
      logger.warn('Output validation issues', {
        persona,
        issues: outputValidation.issues,
        riskLevel: outputValidation.riskLevel,
      });
    }

    // Flag for review if needed
    if (outputValidation.requiresManualReview) {
      try {
        await reviewQueue.flagForReview(
          {
            content: translationResult.content,
            input: { persona, projectName, documentType },
          },
          `${persona} summary requires manual review`,
          outputValidation.issues.map(i => `${i.type}: ${i.description}`)
        );
      } catch (error) {
        // Continue even if flagging fails
        logger.warn('Failed to flag for review', {
          error: error instanceof Error ? error.message : String(error),
        });
      }
    }

    // Get folder ID for this persona
    const folderId =
      folderMapping?.[persona] ||
      this.folderConfig?.[persona] ||
      '';

    if (!folderId) {
      throw new Error(`No folder configured for persona: ${persona}`);
    }

    // Create the document in Google Docs
    const title = `[${persona.toUpperCase()}] ${projectName} - ${documentType} Summary`;
    const docResult = await this.googleDocs.createDocument({
      title,
      content: translationResult.content,
      folderId,
      metadata: {
        persona,
        projectName,
        generatedAt: new Date(),
        transformationDurationMs: Date.now() - startTime,
      },
    });

    // Set permissions if configured
    const permissions = permissionMapping?.[persona];
    if (permissions && permissions.length > 0) {
      await this.googleDocs.setPermissions(docResult.documentId, permissions);
    }

    return {
      persona,
      documentId: docResult.documentId,
      webViewLink: docResult.webViewLink,
      title,
      folderId,
      generatedAt: new Date(),
      tokenCount: Math.ceil(translationResult.content.length / 4),
    };
  }

  /**
   * Create bidirectional links between original and summaries
   */
  private async createBidirectionalLinks(
    originalDocumentId: string,
    summaries: Array<{ persona: PersonaType; documentId: string }>
  ): Promise<void> {
    // Add links from original to all summaries
    for (const { persona, documentId } of summaries) {
      try {
        await this.googleDocs.linkDocuments(
          originalDocumentId,
          documentId,
          `${persona.charAt(0).toUpperCase() + persona.slice(1)} Summary`
        );
      } catch (error) {
        logger.warn('Failed to link original to summary', {
          persona,
          error: error instanceof Error ? error.message : String(error),
        });
      }
    }

    // Add links from each summary back to original
    for (const { persona, documentId } of summaries) {
      try {
        await this.googleDocs.linkDocuments(
          documentId,
          originalDocumentId,
          'Original Document'
        );
      } catch (error) {
        logger.warn('Failed to link summary to original', {
          persona,
          error: error instanceof Error ? error.message : String(error),
        });
      }
    }
  }

  /**
   * Get audience description for persona
   */
  private getAudienceForPersona(persona: PersonaType): string {
    const audiences: Record<PersonaType, string> = {
      leadership: 'C-suite executives and board members',
      product: 'Product managers and designers',
      marketing: 'Marketing team and content creators',
      devrel: 'Developers and technical architects',
    };
    return audiences[persona];
  }

  /**
   * Transform a single document for a specific persona
   */
  async transformForPersona(
    sourceDocument: TransformationInput['sourceDocument'],
    projectName: string,
    documentType: DocumentType,
    persona: PersonaType,
    options: {
      folderId?: string;
      permissions?: Permission[];
      requestedBy?: string;
    } = {}
  ): Promise<PersonaSummary> {
    const result = await this.transform({
      sourceDocument,
      projectName,
      documentType,
      targetPersonas: [persona],
      folderMapping: options.folderId ? { [persona]: options.folderId } as any : undefined,
      permissionMapping: options.permissions ? { [persona]: options.permissions } as any : undefined,
      storeOriginal: false,
      createLinks: false,
      requestedBy: options.requestedBy,
    });

    const summary = result.personaSummaries[persona];
    if (!summary) {
      throw new Error(`Failed to generate ${persona} summary`);
    }

    return summary;
  }

  /**
   * Get pipeline health status
   */
  async healthCheck(): Promise<{
    healthy: boolean;
    components: Record<string, { healthy: boolean; details: string }>;
  }> {
    const components: Record<string, { healthy: boolean; details: string }> = {};

    // Check Google Docs
    try {
      const googleDocsHealth = await this.googleDocs.healthCheck();
      components.googleDocs = googleDocsHealth;
    } catch (error) {
      components.googleDocs = {
        healthy: false,
        details: error instanceof Error ? error.message : String(error),
      };
    }

    // Check context aggregator cache
    const cacheStats = this.contextAggregator.getCacheStats();
    components.contextCache = {
      healthy: true,
      details: `Cache: ${cacheStats.size}/${cacheStats.maxSize} entries`,
    };

    // Check folder configuration
    components.folderConfig = {
      healthy: !!this.folderConfig && Object.values(this.folderConfig).some(v => v),
      details: this.folderConfig
        ? `Configured personas: ${Object.entries(this.folderConfig)
            .filter(([, v]) => v)
            .map(([k]) => k)
            .join(', ')}`
        : 'Not configured',
    };

    const allHealthy = Object.values(components).every(c => c.healthy);

    return {
      healthy: allHealthy,
      components,
    };
  }
}

// =============================================================================
// Export Singleton Instance
// =============================================================================

export const transformationPipeline = new TransformationPipeline();
export default transformationPipeline;
